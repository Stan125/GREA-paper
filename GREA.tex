% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass[12pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage[margin=3.3cm]{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{graphicx} % support the \includegraphics command and options
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{mathtools}
\usepackage[hidelinks]{hyperref}
\usepackage[usenames, dvipsnames]{color}
\urlstyle{same}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{setspace}
\usepackage{eurosym}
\usepackage{listings} %% for R Code

%%% Listings options
\lstdefinelanguage{Renhanced}[]{R}{
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-, ::},
  morekeywords={},
  deletekeywords={hist, runif, plot,  , read.table, read, check, text, file, attributes, quote, missing, c, list, any, which, na, deparse, structure, install},
  alsoletter={.\%},%
  alsoother={:_\$}}

 \lstset{ 
  language=Renhanced,                     % the language of the code
  basicstyle=\small\ttfamily, % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{Blue},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it is 1, each line will be numbered
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=false,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{RoyalBlue},      % keyword style
  commentstyle=\color{YellowGreen},   % comment style
  stringstyle=\color{ForestGreen}      % string literal style
} 

\renewcommand{\lstlistingname}{Code-Chunk}

%%% New commands
\newcommand{\li}{\lstinline}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\usepackage{setspace}
\onehalfspacing

%%% END Article customizations

%%% The "real" document content comes below...

\begin{document}
\newgeometry{margin=2.5cm}
\begin{titlepage}
\thispagestyle{empty}
\newcommand{\HRule}{\rule{\linewidth}{0.6mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{Georg-August UniversitÃ¤t G\"ottingen}\\[1.5cm] % Name of your university/college
\textsc{Statistical Programming with R}\\[0.5cm] % Major heading such as course name

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
\begin{spacing}{1.5}
{ \LARGE \bfseries Gotta Read 'Em All: An RStudio Add-In to visually read different file-formats into R}\\% Title of your document
\end{spacing}
\HRule \\[1.5cm]

%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
Stanislaus \textsc{Stadlmann},\\
Student ID: 21144637
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Supervisor} \\
Paul \textsc{Wiemann}, M.Sc.\\ % Supervisor's Name
\end{flushright}
\end{minipage}\\[4cm]

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large Submitted on \today}\\[3.2cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics{figures/logo}\\[1cm]
 
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace
\end{titlepage}
\restoregeometry
\clearpage

\tableofcontents

\pagenumbering{Roman}

\clearpage

\listoffigures

\lstlistoflistings

\clearpage

\pagenumbering{arabic}

\section{Motivation}

R is a statistical software with an almost uncountable number of functions for different statistical methods, procedures and graphs. The Comprehensive R Archive Network (CRAN), the most popular network for adding new features to R via so called ``packages'', has more than 8000 different packages ready to be downloaded\footnote{There were exactly 8895 packages on CRAN at August 4, 2016.}. Each of them provide a variety of functions to solve different tasks. For example, a package called ``Vector Generalized Linear and Additive Models" (or short VGAM) can be easily installed via the R command \li{install.packages("VGAM")} and, once loaded in R, provides functions to estimate a variety of different regression models.

These aforementioned packages with the underlying functions make R the popular statistical package it is today. But most of these additional features require data to be of any use, most prominently regression model estimation functions. Datasets do exist shipped with R but for most academic purposes, external data will be required to generate new insights.

There are multiple ways of reading data into R depending on the data type (e.g. .csv, .xlsx) and also the data size (big data, small data). Reading a .csv file, for example, can be achieved via the built-in R function \li{base::read.table("filename.csv")}. Big .csv files can be read very quick with the function \li{data.table::fread("bigfile.csv")} from the data.table package \cite[Dowle et al 2015]{w5}. Other packages provide even more functionality, e.g. for dealing with strings or a smaller number of required arguments inside of a function. Most of those packages are also available on CRAN. 

The availability of packages to read different filetypes in numerous ways is very helpful for the advanced R user, because there is almost no filetype that cannot be read via an R function. But it also poses a problem: ff there are so many ways that a user can read a file into R, how will she/he remember all the necessary packages and functions, and their function arguments? This problem is often encountered by new R users who want to use R's extended functionalities but fail at importing data into their working environment.

An answer to this problem is provided by Thomas Leeper's R package called ``rio" \cite[Leeper et al 2016]{w6}, which tries to minimize redundancy by wrapping R reading functions into one import \li{rio::import()} and one export function \li{rio::export()}. 

The R package introduced with this paper takes it one step further. Built on the Shiny Framework and implemented as an RStudio Add-In, ``Gotta Read 'Em All" provides a GUI for reading all different file-formats into R. 

The general process is the following: in the beginning, the user selects a file on her/his computer. After some adjustments (which are done interactively), the proper function to read the file is pasted into the console, with an object name that can be specified by the user. In between, the user can always head to the preview to see what the parsed file would look like with the current options.

Using this Add-In, the user can now read data into R without remembering any code, but still obtains the correct R code to re-parse the data at a later point. 

\section{Underlying Frameworks}

\subsection{The Shiny Framework}

The Shiny Framework\footnote{\url{http://shiny.rstudio.com}} is in itself an R package designed to create interactive visualisations with R functions and HTML code. The author describes the package as ``combining the computational power of R with the interactivity of the modern web" \cite[RStudio 2016]{w3}. The goal is to create applications with clickable interfaces quickly showcasing different scenarios. This is done via reactive R functions, which are run everytime a user interacts with the GUI. 

\begin{figure}[h]
\begin{centering}
\includegraphics[scale = 0.5, trim = 50 50 50 100]{figures/example_shiny_app.png}
\caption{Screenshot of an example Shiny Application.}
\label{exampleapp}
\end{centering}
\end{figure}

Figure \ref{exampleapp} shows an example Shiny Application, consisting of some user interface (UI) control elements (a select button, and tick boxes) and a graph. The UI is reactive; whenever the user ticks a box or selects a different value in the first box, the graph changes its look. This is built upon reactive functions, which run every time a value inside them changes. The values that are allowed to change are therefore bound to the UI elements.

Shiny Apps consist of two elements: The UI and a ``server" side. The UI includes functions which wrap HTML to build the viewable part of the App, for example buttons and placement of graphs. The server side consists of functions that specify the reactive R functions which create dynamic output displayed on the UI side, and when the functions should be run. Both sides then are able to automatically communicate with each other to create a smooth interactive experience for the user. The code for an example Shiny app is attached below:

\begin{lstlisting}[caption = Example code for a Shiny Application\cite{w2}., label = code:exampleapp]
# Define UI
ui <- bootstrapPage(
  numericInput("n", "Number of obs", 100),
  plotOutput("plot")
)
# Define Server
server <-  function(input, output) {
  output$plot <- renderPlot({ hist(runif(input$n)) })
}
app <- shinyApp(ui, server)
# Run App
runApp(app)
\end{lstlisting}

It is now possible to see in Code-Chunk \ref{code:exampleapp} that both the UI and server elements are R objects, while the server also resembles an R function. \li{runApp()} then opens up the Application.

\subsection{Shiny Gadgets and RStudio Add-Ins}
\label{shinyrstudiochapter}

Shiny Applications are useful for displaying interactive visualisations, but they are made for displaying results to the end user. ``Shiny Gadgets"\footnote{\url{http://shiny.rstudio.com/articles/gadgets.html}}, an extension of the Shiny framework, are supposed to be part of the programming or analysing process. They are built on the same framework that was introduced with Shiny, but serve the purpose of making programming challenges a little easier. For example, a Shiny Gadget could be used to provide a UI for downloading certain data from complex websites. 

``RStudio Add-Ins"\footnote{https://rstudio.github.io/rstudioaddins/} are Shiny Gadgets that are built right into RStudio, an Integrated Developer Environment (IDE) for R. Calling the Shiny Gadget is made easier, as the RStudio user only has to press two buttons. Furthermore, Add-Ins have extended access to RStudio itself via a package called ``rstudioapi" \cite[Wickham and Allaire 2016]{w7}. For example, Add-Ins are able to paste a string into the console and can modify the currently opened R script.

The combination of the Shiny framework and RStudio add-ins creates the ideal setting for an Add-In that helps the user parse any data format into R. The Shiny Framework provides interactiveness and the RStudio connection makes it easier to call the Application out of an IDE.

\section{Implementation}

An R-Studio Add-In has to be installed via the R package ecosystem, so GREA is also wrapped up in a package called GREA. Calling the Add-In is done via the main function \li{GREA::GREA()}. Also, there exist a couple of helper functions, which were necessary to reduce redundant R code.
The following functions are implemented:

\begin{itemize}
\item \li{GREA()}
\item \li{GREA_read()}
\item \li{wd_check()}
\item \li{fileChoose()}
\end{itemize}

As stated above, \li{GREA::GREA()} is the function that starts the Add-In. \li{GREA::GREA_read()} is the most important helper function, which converts any filetype into the data.frame R class inside the global environment. For checking if a file is inside the current R working directory, \li{GREA::wd_check()} was written. This function was created from my personal frustration with large filepaths. \li{GREA::fileChoose()} has the same utility as \li{base::file.choose()} (choosing a file interactively), except that it returns \li{NULL} when cancelled.

\subsection{The Main Function: \textrm{GREA()}}
\label{mainfunctionchapter}
As explained in Chapter \ref{shinyrstudiochapter}, Add-Ins are built on the Shiny Framework. \li{GREA()} is therefore also a wrapper for a Shiny Application. In this section, the general structure of the function will be demonstrated.

\begin{lstlisting}[caption = Structure of the \li{GREA()} function, label = greacode]
GREA <- function() {
  ui <- miniPage(
    # User Interface Functions #
    # ...
  )
  server <- shinyServer(function(input, output, session) {
    # Reactive Server Functions #
    # ...
    observeEvent(input$done, {
      # Functions that paste the code into the console
    })
  })
  # Functions that start the Add-In
  app <- shinyApp(ui = ui, server = server)
  viewer <- dialogViewer(dialogName = "GREA", 
                         height = 350, width = 500)
  runGadget(app, viewer = viewer, stopOnCancel = FALSE)
}
\end{lstlisting}

Code-Chunk \ref{greacode} shows the structure of GREA's main function. Similarly to Shiny Applications, we can see that the \li{ui}(lines 2-5) and \li{server}(lines 6-12) objects are specified first. For creating the \li{ui} object, the \li{miniUI::miniPage()} function from the miniUI package \cite[Cheng 2016]{w4} is used, which is specifically targeted at small user interfaces in the style of smartphone apps. The \li{server} object, also resembling an R function, consists of reactive functions that are called every time the user interacts with the UI. This includes the selection of a file to be read in on the user's computer, or the adjustment of reading conditions (e.g. a change in the comma seperator in text-delimited files).

Next, both objects are assembled to a new object called \li{app}(line 14). In lines 15 and 16, an object named \li{viewer} is generated via \li{shiny::dialogViewer()}. This step ensures that GREA is started as an integrated window in RStudio with the right height and width. In the end, the function \li{runGadget()}(line 17) is called to start the Add-In. In essence, this function has the same functionality as the \li{shiny::runApp()} function, with the addition of better automatic handling in the event of the user cancelling the app.

The piece of code that sets this Add-In apart from Shiny applications and Shiny Gadgets is resembled by the contents of lines 9-11, a function which is run when the user presses the ``done" button.

\begin{lstlisting}[caption = Contents of reactive function for ``Done"-event, label = doneeventcode]
observeEvent(input$done, {
  # Paste Code into Console
  if (nzchar(fileloc()) && nzchar(input$name_dataset) && !is.null(dataset())) {
    # Get code that was used to read dataset
    expr <- attributes(dataset())$GREAcommand
    # Assemble code
    code <- paste0(input$name_dataset, " <- ", expr)
    # Paste into Console
    rstudioapi::insertText(text = code, id = "#console")
  }
  # ... and then stop the app
  stopApp()
})
\end{lstlisting}

Code-Chunk \ref{doneeventcode} shows the detailed contents of lines 9-11 in Code-Chunk \ref{greacode}. After the user has specified all necessary variables interactively, she/he presses the ``done" button. This triggers the event called \li{input$done}, which leads to the above function being called.

Line 3 checks if three conditions are met: 
\begin{enumerate}
\item A file location is correctly specified.
\item A dataset name is correctly specified.
\item Reading the dataset with the options provided by the user is successful.
\end{enumerate}

These conditions make sure that the user doesn't obtain code for reading a file which will yield an error. If and only if these conditions are met, the code to read the data is assembled (lines 5-7)  and then pasted into the R console (line 9). The procedure to paste the code into the console makes use of the \li{insertText()} function from the ``rstudioapi" package, previously mentioned in Chapter \ref{shinyrstudiochapter}. After this procedure, the user obtains the code to read the specified file and only has to execute the command to attach the new data to R's global environment.

irgendwo muss hier noch rein was alles dazwischen passiert und wo sozusagen die specifications sind vor allem im server

vielleicht implementation vor das andere packen?

\subsection{The File Reading Function: \textrm{GREA\_read()}}
Chapter \ref{mainfunctionchapter} explained the implementation of the main function, \li{GREA::GREA()}. Though this function is the cornerstone of the overall Add-In, it relies heavily on a function that reads filetypes into R, \li{GREA::GREA_read()}. Writing this function was challenging, as it had to fulfill the following requirements at once:

\begin{enumerate}
\item Read a filetype and convert it to an R object.
\item Keep the code after a successful reading and attach it to the R object.
\item Omit rarely used arguments in the code that should be pasted into the console (e.g. \li{NA} values).
\end{enumerate}

Requirement 1 is the goal that many R reading functions want to achieve. Requirement 2 is necessary, because after successful interactive parsing, the right code should be pasted into the active R console. Requirement 3 was included, because only the reading conditions that are not default values should be included in the code that the user obtains in the end.

To fulfill Requirement 1, \li{GREA_read()} automatically detects the filetype of the selected file. Then, depending on which filetype was detected, it utilizes the following functions from other packages to read data:

\begin{itemize}
\item \li{base::read.table()} for text-delimited files (e.g. .csv, .txt, etc),
\item \li{R.matlab::readMat()} for .mat files (MATLAB) \cite[Bengtsson 2016]{w8},
\item and \li{rio::import()} for all other filetypes.
\end{itemize}

After detecting the filetype and selecting the right function for reading, a ``call" is assembled. In general, an R call is an executed or non-executed command. In this case, the command is created depending on the arguments that the user specified. To show the procedure, an example code snippet is provided below.

\begin{lstlisting}[caption = Reading procedure of \li{GREA_read()}, label = readingprocedure]
else if (any(filetype == c("xls", "xlsx"))) {
      expr <- quote(rio::import())
      expr[c("file", "which")] <- list(filelocation, sheetIndex)
      if (!missing(na.values))
        expr[c("na")] <- na.values
      if (skip > 0)
        expr[c("skip")] <- skip
    }
\end{lstlisting}

In Line 1 of Code-Chunk \ref{readingprocedure}, the condition for the selected file being of an Excel type (.xls, .xlsx) is examined. Once the condition is met, Line 2 utilizes the \li{base::quote()} function, which creates a non-executed call of the first argument, in this case \li{rio::import()}. In Line 3, the arguments \li{file} (filelocation) and \li{which} (which of the Excel sheets should be parsed) are specified using the arguments of \li{GREA::GREA_read()}. Lines 4-7 fulfill Requirement 3 which was specified at the beginning of this chapter: For rare function arguments, these arguments should only be included when they are explicitly specified. In this case, arguments \li{na} and \li{skip} are only then added to the call (object \li{expr}) when they deviate from default values (\li{na.values} is not a missing argument and \li{skip} is greater than 0).

After the call is assembled correctly, it should not only be executed (Requirement 1), but it should also be attached to the object that was created during the call (Requirement 2). This is achieved by the following code at the end of the function:
\begin{lstlisting}[caption = Return Command of the \li{GREA_read()} function, label = returnread]
return(structure(eval(expr), GREAcommand = deparse(expr)))
\end{lstlisting}

Code-Chunk \ref{returnread} shows the execution of said assembled call. The \li{eval()} command first executes it and the \li{structure()} function then attaches the non-executed call (\li{expr}) to the object that was created, thus fulfilling Requirements 1 and 2. Afterwards, the enhanced object is returned (including its attribute).

Whenever a file is now read into the R environment via \li{GREA_read()}, the code that was used can be accessed.

\subsection{Helper Functions}
The GREA package features two helper functions: \li{fileChoose()} and \li{wd_check()}. As mentioned before, \li{fileChoose()} is just an enhanced version of \li{base::file.choose()} that returns \li{NULL} if the interactive file selection is cancelled. \li{wd_check} has two tasks. First, it transforms Windows filepaths to a path that can be read by any Operating System. Second, the function checks if a file selected via \li{fileChoose()} lies inside of the current R working environment, thus being able to shorten the filepath while reading files (that is were it got its name from). The returned object is just another filepath, which is only a subpath if the file lies inside the current R working directory. 

\section{Usage}

\subsection{Requirements}

RStudio Add-Ins require the newest release of RStudio\footnote{RStudio can be downloaded here: \url{https://www.rstudio.com}.} and R\footnote{R can be downloaded here for all major platforms: \url{https://www.r-project.org}.}.

\subsection{Installation}
The Add-In was uploaded to GitHub (an open-source code sharing platform), so it can be easily installed. Installation is done via the following code: 
\begin{lstlisting}[caption = Installation of GREA, label = installationcode]
if (!require(devtools))
  install.packages("devtools")
devtools::install_github("Stan125/GREA")
\end{lstlisting}

Lines 1-2 of Code-Chunk \ref{installationcode} check if the devtools package is installed and install it if not. After executing Line 3, GREA is installed on the user's computer.

\subsection{Starting the Add-In}

To call the Add-In, the user has to click on the Add-In Tab in RStudio and select ``Gotta Read Em All". The Add-In itself then pops up.

\subsection{Selecting the Dataset}

\begin{figure}
\center
\includegraphics[scale = 0.7]{figures/step1.png}
\caption{Selecting a file}
\label{stepone}
\end{figure}

Once the Add-In is started up, the user has to press the "Select File" button to select a file on your computer, as seen in Figure \ref{stepone}. Then, he/she can type in a name for the name of the dataset in R. A suggestion is made via the selected file's filename. Once the file is loaded into the Add-In, additional options for parsing the file on the right are displayed, depending on the filetype. After the user has made his/her adjustments, he/she can click on the previews tab.

\subsection{The preview window}

\begin{figure}
\center
\includegraphics{figures/step2.png}
\caption{Looking at the preview window}
\label{steptwo}
\end{figure}

The previews tab (Figure \ref{steptwo}) shows a preview of what the dataframe would look like if the user parsed it with the current settings. If something looks odd (e.g. column names fell into the first row of the dataset), the first tab has to be selected again. We can see that in our case, the column and decimal separators are wrongly specified. If everything is right, it is still recommended to head to the first tab.

\subsection{Adjusting reading conditions}

\begin{figure}
\center
\includegraphics[scale = 0.8]{figures/step3.png}
\caption{A ready-to use R command created by GREA}
\label{stepthree}
\end{figure}

If the preview of the dataframe seemed off, the user now has the chance to adjust some parameters (e.g. Sheet Index for Excel files, or separator for .csv files). Additional optional parameters can be found in the ``Advanced Options" tab. When a name is specified for the newly acquired dataset, the user presses ``done". Afterwards, the function to read the dataset is pasted into the current R console (as seen in Figure \ref{stepthree}), so the user can store it for future use.


\clearpage

\begin{thebibliography}{59}
\begin{singlespace}

\bibitem{w8}
H. Bengtsson (2016). \emph{R.matlab: Read and Write MAT Files and Call
MATLAB from Within R}. R package version 3.6.0.
\url{https://CRAN.R-project.org/package=R.matlab}.

\bibitem{w2}
W. Chang et al (2016).
\emph{shiny: Web Application Framework for R}. R package version 0.13.2.
\url{https://CRAN.R-project.org/package=shiny}.

\bibitem{w4}
J. Cheng (2016). \emph{miniUI: Shiny UI Widgets for Small Screens}. R
package version 0.1.1. \url{https://CRAN.R-project.org/package=miniUI}.

\bibitem{w5}
M. Dowle et al (2015). \emph{data.table: Extension of Data.frame}. R
package version 1.9.6. \url{https://CRAN.R-project.org/package=data.table}.

\bibitem{w6}
T. Leeper et al (2016). rio: \emph{A Swiss-army knife for data file I/O}. R package version 0.4.8. 
\url{https://CRAN.R-project.org/package=rio}.

\bibitem{w3}
RStudio (2016). 'Powerfully interactive'. \emph{Shiny byRStudio}.
Available: \url{http://shiny.rstudio.com} 
[Accessed 16 August 2016].

\bibitem{w1}
The Comprehensive R Archive Network (2016). 'Contributed Packages'. \emph{CRAN}.
Available: \url{https://cran.r-project.org/index.html} 
[Accessed 4 August 2016].

\bibitem{w7}
H. Wickham and J. Allaire (2016). \emph{rstudioapi: Safely Access the
RStudio API}. R package version 0.6.
\url{https://CRAN.R-project.org/package=rstudioapi}.





\end{singlespace}
\end{thebibliography}
\end{document}